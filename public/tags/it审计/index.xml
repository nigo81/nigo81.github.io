<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>IT审计 - 标签 - 逆行的狗</title>
        <link>https://nigo81.github.io/tags/it%E5%AE%A1%E8%AE%A1/</link>
        <description>IT审计 - 标签 - 逆行的狗</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>tujiabing81@163.com (nigo)</managingEditor>
            <webMaster>tujiabing81@163.com (nigo)</webMaster><lastBuildDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://nigo81.github.io/tags/it%E5%AE%A1%E8%AE%A1/" rel="self" type="application/rss+xml" /><item>
    <title>IT审计之辅助财务审计</title>
    <link>https://nigo81.github.io/posts/20220918151947-it%E5%AE%A1%E8%AE%A1%E4%B9%8B%E8%BE%85%E5%8A%A9%E8%B4%A2%E5%8A%A1%E5%AE%A1%E8%AE%A1/</link>
    <pubDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>nigo</author>
    <guid>https://nigo81.github.io/posts/20220918151947-it%E5%AE%A1%E8%AE%A1%E4%B9%8B%E8%BE%85%E5%8A%A9%E8%B4%A2%E5%8A%A1%E5%AE%A1%E8%AE%A1/</guid>
    <description><![CDATA[<p>在实践中， IT 审计团队通常是和财务审计团队配合完成审计工作的，区别是财务审计是对被审计单位的财务报表及其附注发表意见，而 IT 审计是对信息系统发表意见。</p>
<p>我们所做的工作是通过测试财务报表所依赖的信息系统(包括财务系统和业务系统）的有效性、数据的真实性，证明信息系统环境是否可以信赖。从某种意义上来说， IT 审计是服务于财务审计。</p>
<p>随着财务审计对 IT 审计工作的了解，他们会对 IT 审计提出更多 IT 审计工作范围外的期待。</p>
<p>尤其是在企业信息化浪潮下，受限于技术能力，财务审计团队在数据处理，方法创新方面对 IT 审计团队提出了更高的要求。因此 IT 审计如何更好地辅助财务审计是一个新的课题。</p>
<h2 id="利用python代替繁重计算">利用Python代替繁重计算</h2>
<p>在财务审计中存在大量数据处理、数据计算的基础性工作，对于这类有逻辑重复性工作， IT 审计团队可以借助 Python 批量完成。</p>
<h3 id="成本还原">成本还原</h3>
<p>对于生产制造业的 IPO 审计项目，成产品的料工费占比是财务审计特别关注的事项。而很多企业采用了逐步结转分步法来核算生产成本，由于每一道工序的半成品将是下一道工序的原材料，所以要计算产成品真实的料工费占比就需要进行成本还原。</p>
<p>如果企业使用的 ERP 系统没有还原后的成本结构报表，同时财务成本会计也未手工编制成本结构报表，那么这项核查工作对于财务审计来说将是巨大的工作量。</p>
<figure>
</figure>

<p>对于这类财审提出的需求，我们会了解企业的生产工艺，以及成本还原的计算方法，再利用 Python 编程语言，模拟成本还原的计算过程，将产成品拆分成真实的料工费，从而计算出料工费的占比。</p>
<p>通过 IT 审计团队的辅助，财审团队能完成人工短时间无法完成的工作。</p>
<h3 id="保费收入与收款流水核对">保费收入与收款流水核对</h3>
<p>在一家保险公司 IT 审计项目中，财审团队需要我们对保费收入与收款流水进行数据核对。</p>
<p>当我们了解到业务中存在大量多个保单对应多个收款流水的情况，对于这种多对多关系，正常是无法批量核对的。</p>
<figure>
</figure>

<p>一般情况下，我们核对的数据关系要么是一对一、多对一或者一对多。这三种情况我们写 SQL 语句时都很好处理，只需要将多条数据按单号聚合汇总再进行核对就可以。</p>
<p>这种多对多的关系我们可以借助数学图论中的二分图解决。</p>
<p>比如，我们将这种关系画上线，可以看到其中可以形成一些独立的网络，这里我们将这种网络（用不同颜色标记）简称为组。</p>
<p>我们将独立的网络编上组号，然后将两个数据集的金额分别按组号汇总再进行核对。</p>
<p>示例 Python 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">setA</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">setB</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setA</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setB</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">split_net</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="bp">self</span><span class="o">.</span><span class="n">loop_net</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">loop_net</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setA</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">                <span class="n">sub_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setA</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">sub_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setB</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">sub_node</span> <span class="ow">in</span> <span class="n">sub_nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">sub_node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">sub_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">                        <span class="bp">self</span><span class="o">.</span><span class="n">loop_net</span><span class="p">(</span><span class="n">sub_node</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">net</span><span class="o">.</span><span class="n">split_net</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span></span></span></code></pre></div>
<p>我们借助 Python 构建了类<code>Net</code>,通过 <code>loop_net</code>函数递归找出两个数据集形成的独立网络，从而给独立网络分组，最后我们可以将两个数据集分别按组号聚合后进行核对。</p>
<h2 id="利用python获取外部信息">利用Python获取外部信息</h2>
<p>在财务审计过程中，外部信息的可靠性大于内部信息，因此审计师会查询大量的外部信息与获取的内部信息做交叉验证。</p>
<p>例如，审计一家汽车硬件销售的企业，财务审计团队计划查询销售订单中对应的汽车车架号的信息，核实有没有真实车辆以及车型信息，以及判断查询的外部信息与订单信息是否存在矛盾。</p>
<p>企业 1 年的销售订单有 30 万，依赖审计师人工查询将不太现实。那么，我们 IT 审计团队提出了两种方案：</p>
<ol>
<li>购买接口，通过 python 调用接口批量获取数据。</li>
<li>编写爬虫，通过 python 编写爬虫获取公开网站数据。</li>
</ol>
<p>出于节约成本考虑我们选择编写爬虫获取公开信息，用 python 的selenium包，自动查询网站数据，并将结果保存到本地文件。</p>
<p><a href="https://mpvideo.qpic.cn/0bc35aacyaaa5aacjvv2vfqvb2gdftuaalaa.f10002.mp4?dis_k=78250b45e8ef9c34e7a88d9aabbf2f17&amp;dis_t=1663494076&amp;vid=wxv_2180860661377925123&amp;format_id=10002&amp;support_redirect=0&amp;mmversion=false" target="_blank" rel="noopener noreffer ">视频</a></p>
<p>最后再由财务审计团队对外部信息与内部信息的一致性进行判断。</p>
<p>当然，对于很多公开网站都会有反爬措施，如验证码、访问频率限制、字体混淆等，对于我们 IT 审计团队提出了一定的技术要求。</p>
<p>除此外，财务审计对于外部信息的获取有很大的需求，如同行业财务指标、公司公告、发函快递信息、汇率、交易性金融资产价格等等。</p>
<p>这类需求，随着这几年的发展已有很多成熟的商业网站可以满足，但对于一些特殊的、行业属性较强的小众信息，如果不能批量查询，那么 IT 审计团队就可以辅助财务审计完成信息获取工作。</p>
<h2 id="利用it技术进行方法创新">利用IT技术进行方法创新</h2>
<p>2020年 6 月24日，证监会依法对獐子岛公司信息披露违法违规案作出行政处罚及市场禁入决定。证监会将渔船的北斗定位信息，通过第三方机构还原出航行轨迹，从而计算出采捕区域面积，进而估算真实成本。</p>
<p>根据这则公开披露的信息，启发了我们利用信息技术的优势，对相关数据进行深入分析挖掘，使审计工作更加智慧、高效。我们 IT 审计团队相对有信息技术的优势，而财务审计团队在财务处理、项目风险识别等方面更有优势，两个团队的良好融合会发挥1+1&gt;2的效果。</p>
<p>对于这类精纬度空间信息，我们可以通过 Python 计算面积、周长、距离。</p>
<figure>
</figure>

<p>示例 Python 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pyproj</span> <span class="kn">import</span> <span class="n">Geod</span> <span class="c1"># 导入Geod类</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span> <span class="c1"># 导入点、线、多边形类</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算封闭区域面积、周长</span>
</span></span><span class="line"><span class="cl"><span class="n">geod</span> <span class="o">=</span> <span class="n">Geod</span><span class="p">(</span><span class="n">ellps</span><span class="o">=</span><span class="s2">&#34;WGS84&#34;</span><span class="p">)</span> <span class="c1"># 创建一个WGS84坐标系</span>
</span></span><span class="line"><span class="cl"><span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mf">116.169465</span><span class="p">,</span> <span class="mf">39.932670</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.160260</span><span class="p">,</span> <span class="mf">39.924492</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.150625</span><span class="p">,</span> <span class="mf">39.710019</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.183198</span><span class="p">,</span> <span class="mf">39.709920</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.226950</span><span class="p">,</span> <span class="mf">39.777616</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.442621</span><span class="p">,</span> <span class="mf">39.799892</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.463478</span><span class="p">,</span> <span class="mf">39.790066</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.588276</span><span class="p">,</span> <span class="mf">39.809551</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.536091</span><span class="p">,</span> <span class="mf">39.808859</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.573856</span><span class="p">,</span> <span class="mf">39.839643</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.706380</span><span class="p">,</span> <span class="mf">39.916740</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.600293</span><span class="p">,</span> <span class="mf">39.937770</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.514805</span><span class="p">,</span> <span class="mf">39.982375</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.499935</span><span class="p">,</span> <span class="mf">40.013710</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.546520</span><span class="p">,</span> <span class="mf">40.030443</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.687668</span><span class="p">,</span> <span class="mf">40.129961</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.539697</span><span class="p">,</span> <span class="mf">40.080659</span><span class="p">),</span> <span class="p">(</span><span class="mf">116.503390</span><span class="p">,</span> <span class="mf">40.058474</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="p">(</span><span class="mf">116.468800</span><span class="p">,</span> <span class="mf">40.052578</span><span class="p">)])</span> <span class="c1"># 将多个精纬度坐标实例化为Polygon多边形对象</span>
</span></span><span class="line"><span class="cl"><span class="n">poly_area</span><span class="p">,</span> <span class="n">poly_perimeter</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">geometry_area_perimeter</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="c1"># 计算多边形面积和周长</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">poly_area</span><span class="p">,</span> <span class="n">poly_perimeter</span><span class="p">)</span> <span class="c1"># 打印面积和周长</span></span></span></code></pre></div>
<p>面积:951546279.1726327 周长:183419.43445625657</p>
<h2 id="结语">结语</h2>
<p>随着新技术、新模式在企业发展过程中不断涌现，财务审计与 IT 审计的融合将会更加紧密。在这样的背景下， IT 审计的工作界限未来可能会更加模糊， IT 审计如何发挥我们的优势辅助财务审计高效、智慧地完成审计工作需要我们共同探索。</p>
]]></description>
</item>
<item>
    <title>IT审计之独立数据核查</title>
    <link>https://nigo81.github.io/posts/20220814214453-it%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%A0%B8%E6%9F%A5/</link>
    <pubDate>Sun, 14 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>nigo</author>
    <guid>https://nigo81.github.io/posts/20220814214453-it%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%A0%B8%E6%9F%A5/</guid>
    <description><![CDATA[<p>&ldquo;数据是 21 世纪的石油，而分析则是内燃机。&rdquo;</p>
<p>如果说数据是石油，其本身是无价值的，只有对数据深度挖掘，才能为企业业务增长提供新的引擎，形成真正的数据资产。</p>
<p>近年来，随着信息技术飞速的发展，企业信息化建设已由类似于 ERP 等行业属性相对较强的信息系统建设转向信息系统之上的数据管理与业务应用建设，如建设适应企业业务发展的数据中台、业务中台等新型 IT 架构。通过建设敏捷高效可复用的支撑平台，为业务数字化创新提供高效数据和服务支撑。</p>
<p>IT审计执行的信息系统一般控制、应用控制测试是对企业信息科技领域管控的评价，仍然是对信息系统基础设施及建立其上的业务流程的控制测试。面对企业业务开展所产生的海量数据，其勾勒出了企业经营活动真实画像，数据核查工作在应对舞弊、异常检测方面显得越来越重要。</p>
<h2 id="数据核查的特点">数据核查的特点</h2>
<h3 id="由抽样审计转变为全量审计">由抽样审计转变为全量审计</h3>
<p>IT审计的数据核查大多时候是为财务审计服务的。受限于技术手段，财务审计在进行数据核查时，往往是抽样审计。但面对类似电商、游戏等这样的互联网企业所产生的海量销售订单，抽样检查多少个合适呢？ 100 个、 1000 个还是 10000 个才合适呢？</p>
<p>借助于 SQL 、ClickHouse等大数据分析技术，我们可以对上亿行的数据量进行全量核查，全量分析。</p>
<figure>
</figure>

<p>例如，对于大型集团企业，审计在执行银行流水与财务序时账核对时一般仅对大额流水进行检查，并且会耗用大量人力和时间。如果企业开通了银企直联，银行流水与序时账一般会有关联字段，我们可以利用 SQL 进行全量双向核对；如果企业未开通银企直联，或没有关联字段，我们仍然可以利用 Python 按照人工核对的逻辑编写代码，实现网银流水与序时账的全量核对，不再区分金额大小。</p>
<p>再如，对于生产工艺复杂的制造型企业，其工序可能多达十几步或者几十步，审计难以对生产成本进行重新计算以验证存货计量的准确性。但对于计算机来说，这些工序的成本分摊逻辑是一致的，借助于 Python ，我们也是可以实现对所有工单的生产成本的归集和分摊进行全量重新计算。对于这些收入、成本计算逻辑复杂的企业，利用 Python 这样的编程语言，复现系统的计算逻辑，能取得很好的数据核查效果。</p>
<h3 id="数据分析的颗粒度更小">数据分析的颗粒度更小</h3>
<p>财务审计在执行分析性程序时，往往使用的数据颗粒度很大，如按年或月的汇总金额去进行波动分析。数据的颗粒度就像一张照片的像素，当颗粒度很大时，照片所呈现的信息将会失真，很多细节信息将难以发现。而 IT 审计进行数据核查时一般按照最小颗粒度的数据进行多维度分析，如订单、小时、分钟、渠道等，这是异常检测的基础。</p>
<figure>
</figure>

<p>如上图所示，当我们将订单按照一天 24 小时划分为 24 个区间，分别统计每个小时区间的订单金额时，能发现 2019 年0点和 2020 年8点的订单金额显示异常。这就是将分析的颗粒度变小的好处，能还原更多细节信息。</p>
<figure>
</figure>

<p>如上图所示，我们甚至可以按分钟去统计次数，去检测是否存在利用机器人等技术短时间大量刷单的情况。</p>
<figure>
</figure>

<p>如上图所示，我们可以以订单的颗粒度去分析单价的稳定性，对于发散的或者偏离正态分布的数据检测出来，进一步去核查异常数据产生的原因。</p>
<h3 id="数据核查对象多样化">数据核查对象多样化</h3>
<p>在大数据时代，几乎所有的人、事、物都能够数据化，进而被分析。</p>
<p>我们将数据核查的对象可以划分为结构化数据和非结构化数据，结构化数据即为能够用数据或者统一结构加以表示的信息，如信息系统中的各种报表。而非结构化数据，就是一些无法用数字或统一的结构表示，如合同、发票、邮件、网页等。</p>
<p>IT审计数据核查的对象不再局限于财务账、业务报表等结构化数据，借助于新的 IT 技术，我们可以将数据核查的范围延伸到非结构化的数据。</p>
<figure>
</figure>

<p>如上图所示，审计一家航运企业，以前我们只能通过手工抽样查询船舶定位位置与业务系统中的班期表核对，验证航行的真实性。现在我们可以利用 Python 爬虫技术，批量解析网页中船舶经纬度信息和出发地、目的地，全量核对。</p>
<figure>
</figure>

<p>如上图所示，借助于 OCR 技术，我们可以将非结构化的发票图片文件识别成结构化数据，从而实现发票的全量核查。</p>
<p>当然，我们还可以将数据划分为财务数据、业务数据、日志数据三种类型，财务审计在做数据核查时更多核查的是财务数据。而 IT 审计核查的对象会延伸到业务数据和日志数据。</p>
<p>从企业舞弊造假成本来说，=财务数据&lt;业务数据&lt;日志数据=，我们更倾向于通过日志数据、业务数据的核查来验证财务数据的真实性、准确性、完整性。</p>
<figure>
</figure>

<p>如上图所示，审计一家制造型企业，我们获取了公司 ERP 系统的操作日志，按天对作业频率进行分析，检查作业频率异常偏高的情况，以排查是否存在舞弊迹象。由于操作日志真实反映了人员的所有系统操作，其数据的可信度相比财务数据更高，能更好地应对舞弊欺诈行为。</p>
<p>总之， IT 审计的数据核查的来源具有多样化的特点。</p>
<h2 id="数据核查的方法">数据核查的方法</h2>
<p>IT审计数据核查需要将 IT 技术与审计方法相结合。在信息技术飞速发展的浪潮下，我们需要拥抱新技术、新思想、新变革，同时对我们的审计思路、审计模式进行创新。</p>
<p>审计一家游戏企业，玩家通过充值获得游戏币，游戏币可以在商城中购买游戏道具，购买的道具可以自己使用也可以赠送他人。在审计过程中，我们发现一些账号的充值金额异常大，我们利用 Neo4j 图数据库将所有道具的赠送关系进行网络分析：</p>
<figure>
</figure>

<p>我们发现消费金额前 25 名的异常账号，其中就有 19 个账号相互之间有赠送行为，形成了网络。通过进一步审计程序，我们发现其中一些账号是淘宝店家，他们通过从价格更低的渠道充值后，以&quot;赠送&quot;的方式卖给游戏玩家，因此其充值金额较大，且存在大量赠送行为。</p>
<p>利用 Neo4j 、Gephi、 NetworkX 等工具，我们可以轻松地进行复杂网络关系分析，挖掘出数据背后的关联关系，这是新技术为我们数据核查带来了新的手段、新的方法。</p>
<p>但 IT 技术仅仅是一种工具，我们在做数据核查时，更多的需要和我们的审计方法论结合、和生活常识结合、和行业经验结合、和统计学知识结合。</p>
<p>例如， IPO 的电商企业的数据核查要求我们 IT 审计对是否存在刷单行为进行分析，从数据分析的工具上讲，我们使用 SQL 就能进行分析，但我们从什么维度去分析能发现是否存在刷单行为呢？</p>
<p>其实我觉得更好的方法是从生活常识入手，从行业经验入手，我们可以去找参与过刷单朋友，询问他们是如何刷单的，了解其特点，然后再设计数据分析的维度。</p>
<p>例如，我向朋友了解到有的刷单方法是找普通的人去购买，发货的时候只发一个空盒子或者价值较小的重量较轻的东西，完成订单后，再通过微信红包的方式返钱给他。</p>
<p>针对这种刷单方式，我们就可以利用“发货重量轻“的特征去筛选出这些异常订单。我们可以根据商品 SKU 的重量信息，计算出系统里一个订单的重量，再去和物流公司发货时称重重量核对，从而检测出重量偏离较大的异常订单。</p>
<p>当然，这只是一个举例，通过这个例子，我想说明在 IT 审计数据核查过程中分析的思路很多时候比技术手段更加重要。</p>
<p>我们正处在信息爆炸、技术变革的时代，我们应该学习新的 IT 技术，积极探索新的审计方法、审计思路，通过深入挖掘数据背后的价值，提高我们的审计质量、审计效率。</p>
]]></description>
</item>
<item>
    <title>传销组织层级结构分析</title>
    <link>https://nigo81.github.io/posts/20220814001303-%E4%BC%A0%E9%94%80%E7%BB%84%E7%BB%87%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link>
    <pubDate>Sun, 14 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>nigo</author>
    <guid>https://nigo81.github.io/posts/20220814001303-%E4%BC%A0%E9%94%80%E7%BB%84%E7%BB%87%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid>
    <description><![CDATA[<p>前几天一个网友发了一个传销组织的数据，他想求每个层级的人数。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->图1</p>
        </figcaption>
</figure>

<p>这两天正好学了<code>networkx</code>，我们来看如果用网络分析解决这个问题。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->图2</p>
        </figcaption>
</figure>

<p>这是整个推荐关系的可视化网络图。其中正红色的点为根节点。</p>
<p>下面我们一步一步来解决。</p>
<h2 id="读取数据并创建网络">读取数据并创建网络</h2>
<p>我们使用<code>pandas</code>读取 excel 数据，并用<code>nx.from_pandas_edgelist(df,source,target,edge_attr,create_using)</code>函数来创建一个图=G=。</p>
<p>这个函数是根据边数据来创建图，其中：</p>
<ul>
<li>source:df中表示边起始的列名（推荐人）。</li>
<li>target:df中表示边目标的列名（被推荐人）。</li>
<li>edge\_attr:df中表示边属性的列名（如权重，颜色，大小等）。</li>
<li>create\_using:表示创建什么类型的图，无向图，有向图等。这里我们使用有向图=DiGraph=,因为推荐关系是有方向的。</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 读取数据创建图</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="s1">&#39;~/传销原始数据.xlsx&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;推荐人ID&#39;</span><span class="p">,</span> <span class="s1">&#39;被推荐人ID&#39;</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">())</span></span></span></code></pre></div>
<p>当然这样创建的图=G=只是一个类的实例化，并不一张真正可视化的图。如果你想可视化它，可以使用=pyvis=包进行，它可以生成一个可交互的网络图。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pyvis.network</span> <span class="kn">import</span> <span class="n">Network</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s1">&#39;650px&#39;</span><span class="p">,</span> <span class="s1">&#39;1250px&#39;</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span><span class="o">.</span><span class="n">from_nx</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="s1">&#39;test.html&#39;</span><span class="p">)</span></span></span></code></pre></div>
<p>这将会生成如图 2 所示的网络图。</p>
<h2 id="找到根节点">找到根节点</h2>
<p>考虑到这个网络是一个传销组织，那么正常情况下应该是有个唯一的根节点，整个组织类似树状结构。</p>
<p>我们先得找到这个根节点，怎么找呢？</p>
<p>这就需要先引一个图论中的概念<strong>度</strong>，度的意思就是一个节点的相邻节点的数量。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 3: <!-- raw HTML omitted -->图3</p>
        </figcaption>
</figure>

<p>如图 3 所示，如果不考虑边的方向，那点节点 1 有4个相邻节点（有边相连），那么节点 1 的度就是 4 。</p>
<p>即<code>degree=4</code>。</p>
<p>但是这是一个有向图，就会分成<code>in_degree</code>和 <code>out_degree</code> 两种度。</p>
<p>那么我们要找到根结点，只需要去找<code>in_degree==0</code>的节点就是根节点，同理<code>out_degree==0</code>的节点为末级节点。</p>
<p>因此，我们写代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">top_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;root node:&#39;</span><span class="p">,</span> <span class="n">top_nodes</span><span class="p">)</span></span></span></code></pre></div>
<p>可以计算出根结点为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">0</span><span class="p">]</span></span></span></code></pre></div>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 4: <!-- raw HTML omitted -->图4</p>
        </figcaption>
</figure>

<p>如图 4 所示，我们可以找到图中的根节点，它就是这个网络的头目。</p>
<h2 id="计算网络层级关系">计算网络层级关系</h2>
<p>为了计算网络层级关系，这里我们需要引入一个概念*距离*，也就是两个节点之间的最短路径长度。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 5: <!-- raw HTML omitted -->图5</p>
        </figcaption>
</figure>

<p>对于节点 1 到节点 4 的距离为 3 ，因为两条路径可以从节点 1 到达节点 3 ：</p>
<ul>
<li>[1, 2, 3, 4]</li>
<li>[1, 2, 5, 4]</li>
</ul>
<p>这两条路径最短的距离就是 3 。</p>
<p>在<code>networkx</code>库中有个函数<code>nx.shortest_path_length(G,source,target)</code>可以求出节点<code>source</code>和 <code>target</code> 之间的距离。</p>
<p>如果省略<code>target</code>参数，就可以求出<code>source</code>下所有节点与<code>source</code>之间的距离。</p>
<p>因此，我们只需要用=nx.shortest_path_length(G, 0)=就可以求出=根节点0=下的所有节点的距离，也就是*网络层级*。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">level</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">)</span></span></span></code></pre></div>
<p><code>level</code> 的值是下面这样的=节点:距离=的字典，可以看到一共 32 个层级。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="mi">2576</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span> <span class="mi">5659</span><span class="p">:</span> <span class="mi">32</span><span class="p">}</span></span></span></code></pre></div>
<p>我们求出了所有子节点到根节点的距离<code>level</code>列表，用<code>set_node_attributes()</code>函数给每个节点添加一个层级属性。</p>
<p>下面，我们只需要将<code>level</code>列表，统计出 1-32 层级中分别有哪些节点即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 显示层级</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">level</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">nodes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 打印前10层节点</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></span></span></code></pre></div>
<p>这里我们展示前 10 层级对应的哪些节点：</p>
<figure>
</figure>

<p>当然，我们将上面<code>print(l,n)</code>替换成<code>print(l,len(n))</code>，就可以看到每一层级对应的节点数量。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 6: <!-- raw HTML omitted -->图6</p>
        </figcaption>
</figure>

<h2 id="下线前10的节点">下线前10的节点</h2>
<p>我们知道=度=表示了相邻节点数量，那么度值最大的 10 个，也就是下线数最大的 10 个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">degrees</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">top_degree_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">top_degree_nodes</span><span class="p">)</span></span></span></code></pre></div>
<p>计算结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[(</span><span class="mi">2828</span><span class="p">,</span> <span class="mi">264</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">115</span><span class="p">),</span> <span class="p">(</span><span class="mi">2700</span><span class="p">,</span> <span class="mi">86</span><span class="p">),</span> <span class="p">(</span><span class="mi">2833</span><span class="p">,</span> <span class="mi">65</span><span class="p">),</span> <span class="p">(</span><span class="mi">2999</span><span class="p">,</span> <span class="mi">55</span><span class="p">),</span> <span class="p">(</span><span class="mi">2560</span><span class="p">,</span> <span class="mi">53</span><span class="p">),</span> <span class="p">(</span><span class="mi">2574</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="p">(</span><span class="mi">3021</span><span class="p">,</span> <span class="mi">37</span><span class="p">),</span> <span class="p">(</span><span class="mi">2651</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span> <span class="p">(</span><span class="mi">2834</span><span class="p">,</span> <span class="mi">31</span><span class="p">)]</span></span></span></code></pre></div>
<p>可以看到下线最多的节点是<code>节点2828</code>有 264 个下线，第二是<code>根节点0</code>有 115 个下线。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 7: <!-- raw HTML omitted -->图7</p>
        </figcaption>
</figure>

<p>这些节点表现在图中就是像水母一样的中心节点。</p>
<h2 id="最大介绍top10">最大介绍top10</h2>
<p>除了通过=度=来衡量一个节点是否为关键节点外，我们还可以通过介数来衡量。</p>
<p>如图 8 所示，根节点 0 传递到节点1,节点2,节点3&hellip;.</p>
<p>其中节点2,节点 5 的度非常小，分别为 2 和1,但是如果少了他们的话，后面整个网络就断了。</p>
<p>介数就是表示网络中群体与群体之间的中间人角色，现实生活中如果度数大的是黄牛，那么这个介数的中间人就是给黄牛提供渠道的关键人物。</p>
<figure><figcaption>
            <p><!-- raw HTML omitted -->Figure 8: <!-- raw HTML omitted -->图8</p>
        </figcaption>
</figure>

<p>我们在图中将前 10 大中介点标记成了绿色，方便查看。</p>
<h2 id="完整代码">完整代码</h2>
<p>以上分析的完整代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pyvis.network</span> <span class="kn">import</span> <span class="n">Network</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 读取数据创建图</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="s1">&#39;~/传销原始数据.xlsx&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;推荐人ID&#39;</span><span class="p">,</span> <span class="s1">&#39;被推荐人ID&#39;</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 求根节点</span>
</span></span><span class="line"><span class="cl"><span class="n">top_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;root node:&#39;</span><span class="p">,</span> <span class="n">top_nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 节点层级</span>
</span></span><span class="line"><span class="cl"><span class="n">level</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 显示层级</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">level</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">nodes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 打印前10层节点</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印前10大度节点</span>
</span></span><span class="line"><span class="cl"><span class="n">degrees</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">top_degree_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">top_degree_nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 给节点添加属性</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">level</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;level&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 给节点添加大小属于</span>
</span></span><span class="line"><span class="cl">    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">level</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 第一、二、三层节点添加颜色</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fuchsia&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;purple&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 中介点</span>
</span></span><span class="line"><span class="cl"><span class="n">center</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">center_tops</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 给前10大中介点添加颜色</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">center_tops</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;teal&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">write_gexf</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;test.gexf&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s1">&#39;650px&#39;</span><span class="p">,</span> <span class="s1">&#39;1250px&#39;</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span><span class="o">.</span><span class="n">from_nx</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="s1">&#39;test.html&#39;</span><span class="p">)</span></span></span></code></pre></div>
<h2 id="结语">结语</h2>
<p>networkx是复杂网络分析的利器，搭配上可视化库 pyvis ，可以简单几行代码完成分析和可视化。</p>
]]></description>
</item>
<item>
    <title>学习</title>
    <link>https://nigo81.github.io/posts/20220814214247-%E5%AD%A6%E4%B9%A0/</link>
    <pubDate>Sun, 14 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>nigo</author>
    <guid>https://nigo81.github.io/posts/20220814214247-%E5%AD%A6%E4%B9%A0/</guid>
    <description><![CDATA[<p>最近在投一个资金分析的标，需要对几百个账户资金数据进行分析。</p>
<p>一般我们审计一家企业的时候，是很难对资金数据进行穿透的，为什么？</p>
<p>因为我们只有被审计企业的资金账户数据，他的上游、下游的数据我们都不可能获取到。</p>
<figure>
</figure>

<p>所以，我们无法对整个资金链进行穿透。</p>
<p>也就是说，最困难的点是我们没有*数据*。</p>
<p>而这个项目最有意思是公安机关能获取到所有数据，我们需要做的就是分析。</p>
<p>那么在有数据的情况下怎么去分析呢？</p>
<p>用 Excel 肯定不行吧，几百个账户，上亿的流水，眼睛去看或者用公式去看都很难。你很难直观知道这个钱分批转出去后，最终到了哪些账户里。</p>
<p>这就需要复杂网络分析的技术，去找网络中资金走的什么链路，最终归集到哪里，哪些节点是关键节点等等？</p>
<figure>
</figure>

<p>所以这几天我正在学习复杂网络分析的相关知识，以及 python 的=networkx=库。</p>
<p>我非常期待能做这个项目，并把学到的知识运用到实战中。</p>
<h2 id="需求为向导">需求为向导</h2>
<p>我一般不太喜欢去为了学习一个新的知识而学习新的知识，或者是为了考证而考证。</p>
<p>我喜欢在工作中看什么东西对我有用，我再去针对性地去学习，也就是以需求为向导地学习。</p>
<p>这样会有非常大的动力，并且学习过程中，能立马解决现实中的问题，带来强烈的正向反馈，进而促使我投入更多精力去掌握这些新的知识。</p>
<p>随着用这些知识解决问题数量的增多，就会慢慢从入门到精通。</p>
<p>而这个过程是非常有趣的，娱乐的，我感觉很多时候比玩游戏、刷剧有趣多了。</p>
<p>我基本休息的时间，都在干类似的事情，乐于其中。</p>
<p>祝读者周末愉快！</p>
]]></description>
</item>
</channel>
</rss>
